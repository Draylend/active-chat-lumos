% Active Chat Development Plan
% Joshua Zingale
% January 26, 2026

# Introduction

Educators around the world are looking to integrate generative AI into their courses as a way to augment student learning.
In Fall 2025, we therefore made a limited deployment of our [AI Tutor](aitutor.cs.ucr.edu) in two Computer Science courses.
Considering student feedback, we found that students did not find much value in a chatbot,
which they could already get by using Gemini or ChatGPT, that merely had "guardrails" in place
to prevent the divulging of direct answers to students.
Hence, we conclude that any offering of an AI Tutor in future courses must offer a unique experience to students.

Talking with faculty across departments, it is clear to us that everyone has a different manner in which he desires to integrate generative AI into his class. For example,

- The testing center is looking into deploying an AI-Tutor-like service to support a gradable, discussion based examinations, which may include both grading of conversations and direct answering of multiple-choice questions dispensed into the chat interface;
- The writing department is interested in using an AI Tutor as a grammar coach, requiring only a mostly vanilla chatroom experience;
- For computer science courses, the ability to embed a programming environment would allow students to enter code for execution in the chat interface and didactic evaluation by the AI Tutor


Given the differing needs mentioned above, and the many more that have gone unmentioned, we seek to develop of framework for embedding activities into chat-like interfaces. This framework must satisfy the following:

- **Plug-and-Play Extensibility**: Activities should be served dynamically via a registry. Adding a new activity type (e.g., a "Chemical Formula Balancer") should not require a re-deployment of the core chat application.
- **Microservice Architecture**: A specialized back-end will act as the "Activity Server," providing cross-site compatible assets (JavaScript/WASM) to any requesting front-end interface.
- **LLM-Driven Rendering**: The system must utilize XML tags generated by the Language Model to trigger the rendering of specific UI components.
- **Uniform Chat Logs**: All student interactions within an activity (clicks, submissions, code entries) must be transformed back into plain-text representations to be stored within the chat history, ensuring data auditability and replayability.
- **Framework Agnostic**: The system should utilize Web Components (Custom Elements) to ensure that activities can be embedded into any web environment regardless of the host's tech stack.


## Overall project structure

```
active-chat/
├── active-chat-framework/     # Front-end core library
│   ├── src/
│   │   ├── components/        # Internal UI components (active-chat, message)
│   │   ├── parser/            # XML/Markdown parsing logic
│   │   ├── registry-client/   # Logic to fetch and load external components
│   │   └── index.js           # Framework entry point
│   └── styles/                # Global themes and CSS variables
│
├── activity-server/           # Go-based component registry
│   ├── cmd/
│   │   └── registry/
│   │       └── main.go        # Server entry point (handles --component_dir)
│   ├── internal/
│   │   ├── server/            # HTTP handlers and routing
│   │   └── middleware/        # CORS and logging
│   ├── go.mod
│   └── go.sum
│
├── component-library/         # Individual activity web components
│   ├── mcq/                   # Sub-directory named after the component
│   │   ├── index.js           # Main component entry point
│   │   └── static/            # Component-specific static assets
│   │       └── icon.svg
│   ├── coding-sandbox/
│   │   ├── index.js
│   │   └── static/
│   │       └── runner.wasm
│   └── video-player/
│       ├── index.js
│       └── static/
│           └── thumbnail.jpg
│
├── docs/                      # Project documentation and diagrams
│   ├── DEVELOPMENT_PLAN.md
│   └── API_SPEC.md
└── README.md
```

# Specification

This section outlines the specifications for the front- and back-end portions of the framework.

## Front-End Framework

The front-end framework will use [Web Components](https://developer.mozilla.org/en-US/docs/Web/API/Web_components) so as to be agnostic of the tech-stack used.
Web components are more difficult to work with than React or other component frameworks, so you may choose to leverage
a tool to facilitate the creation of web components, like [stencil](https://stenciljs.com/) or [lit](https://lit.dev/).

Chat histories are stored as plain text, where messages typically go back and forth between a user and a chatbot.
To integrate smoothly with this paradigm, easing data processing and database infrastructure, all activities
and responses thereto must be transformed into plain-text representations.
Thus implementing activities, the entire interaction history may be replayed simply by viewing the chat logs of a conversation.

For example, the chatbot may send this across the chat interface:

```xml
<chat-activity activity-id="4">
    <multiple-choice-question>
        <question>What is two minus four?</question>
        <answer>negative two</answer>
        <option>two</option>
        <option>negative four</option>
        <option>negative two</option>
        <option>zero</option>
    </multiple-choice-question>
</chat-activity>
```

The front end framework should read the opening tag, `<chat-activity>`, and know that it needs to render the embedded activity.
If it encounters a tag that it has not rendered in the current browser, like "multiple-choice-question",
it should send a request to the back end to fetch a web component. If no web component is found with the name, a default widget that gives a useful error message, like "Invalid activity specification", should be rendered.

(Obviously, storing the answer to questions in the DOM leaks the answer to any somewhat tech-savy student. Do not worry about this for this project. I have my own system in place for obfuscating such answers that I will employ later down the road.)

In the case of a multiple choice question, we expect that a widget allowing the user to select from the options will appear.
If the user selects "negative four", the following should be sent into the chat interface

```xml
<chat-interaction activity-id="4">
    <selection>negative four</selection>
</chat-interaction>
```

where the `<activity-id/>` matches the corresponding `<chat-activity/>`. This should trigger a change in the rendered state of the multiple choice question,
perhaps highlighting the selected answer in red (because it is wrong) and displaying a hint.
The absence of an `activity-id` for a `<chat-activity/>` might indicate that the "activity" is not actually interactable in a way that should be tracked, for example a video player component.


### Front-End Components

The primary component is `<active-chat/>`.
It is the main chat display, and should render something like a modern chat interface (cf. Gemini, Claude, ChatGPT).
Along with this component is `<message/>`.
An `<active-chat/>` will contain, as sub elements, `<message/>` elements, which themselves contain plain text, which may contain `<chat-activity/>` and `<chat-interaction/>` tags.
Each `<message/>` should also have attributes that specify whether it is from the current user or not and for the name of the sender. For example,

```html
<active-chat>
  <message sender="AI Tutor" is-user="false">
    Hello! Let's test your math skills.
    <chat-activity activity-id="101">
      <multiple-choice-question>
        <question>What is 5 + 5?</question>
        <answer>10</answer>
        <option>5</option>
        <option>10</option>
        <option>15</option>
      </multiple-choice-question>
    </chat-activity>
  </message>
  
  /* User clicks on one of the options, triggering the message to be sent. */
  <message sender="Student" is-user="true">
    <chat-interaction activity-id="101">
      <selection>10</selection>
    </chat-interaction>
  </message>
  
  <message sender="AI Tutor" is-user="false">
    Correct! Well done.
  </message>
</active-chat>
```

should be rendered as a chat interface that has multiple messages.
Each `<message/>` should render text normally.
If a `<chat-activity/>` or `<chat-interaction/>` is encountered in the message, the text should not be rendered as is:
instead, the inner XML should be rendered as HTML using web components.
If a component is not found locally, i.e. in the current web pages namespace, then JavaScript must send a request to the activity server to fetch the web component, then displaying it.



`<chat-interaction/>` should typically not itself be rendered, per se. Instead, when it appears in the chat history, it should modify the display of the `<active-chat/>` that shares its `activity-id`.
To make this manageable, I propose a design that would function with the following snippet:


```javascript

// Generating an interaction message
const activeChatElement = document.querySelector("active-chat");
const activity = activeChatElement.getActivity(101); 

const selectionElement = document.createElement("selection");
selectionElement.innerText = "4";

const activityInteractionElement = activity.createInteractionElement(); 
activityInteractionElement.appendChild(selectionElement);

const messageElement = document.createElement("message");
messageElement.appendChild(activityInteractionElement);
activeChatElement.appendChild(messageElement);

// Applying interactions to activities
document.querySelectorAll(`chat-interaction`).forEach(interaction => {
    const activityId = interaction.getAttribute('activity-id');
    const activity = document.querySelector(`chat-activity[activity-id="${activityId}"]`);
    if (activity && typeof activity.accept === 'function') {
        activity.accept(interaction);
    }
});
```

The `accept` method is an example of the [Visitor Pattern](https://en.wikipedia.org/wiki/Visitor_pattern).


# Back End Activity Registry

The back end is responsible for serving the web components to the front end.
Thus is it a *component registry*. It should have an endpoint at `/components`
that responds to `GET` requests either with a web component, if the component exists,
or with a 404 (Not Found). For example, `/components/mcq` should respond with the `<mcq>` component.

The web server should be configurable so as to make the addition of new components easy.
The server, for example, could be started like

```bash
component-registry --component_dir ./components --port 5000
```

where `./components` contains files like `mcq.js`, which contain the components to be served.
This maximizes configurability. Each component should be in a sub-folder of the components directory that bears the name of the component, like `mcq`.
Inside the directory should be a main component file, `index.js`, alongside a directory called static, which may contain any static files available to the component. Here is an example components directory:

```
components/
├── mcq/
│   ├── index.js        # Main Web Component definition/entry point
│   └── static/           # Asset folder for this specific component
│       └── header.svg
├── coding-sandbox/
│   ├── index.js
│   └── static/
│       └── runner.wasm   # Example of a complex asset
└── video-player/
    ├── index.js
    └── static/
        └── icon.png
```


## Tech stack

Use Go for the web server. It is a performant language designed for the development of web servers.

# Milestones

# Project Milestones: Active-Chat

## Phase 1: Core Interface & Infrastructure
- [ ] **M1.1: Basic Chat Shell**: Implement the `<active-chat/>` container and `<message/>` sub-components to render a standard, scrollable chat UI using static dummy data.
- [ ] **M1.2: Content Parsing**: Implement Markdown support and a text-parsing engine that identifies `<chat-activity>` and `<chat-interaction>` tags within message blocks.
- [ ] **M1.3: Registry Microservice**: Build the Go-based back end capable of serving static JS modules from a configurable directory with proper CORS headers.

## Phase 2: Dynamic Component Loading
- [ ] **M2.1: Activity Discovery**: Implement the front-end logic to detect unknown tags and request the corresponding Web Component from the Go registry.
- [ ] **M2.2: Shadow DOM Rendering**: Successfully render a fetched activity (e.g., a simple `<mcq/>` component) inside the Shadow DOM of a chat message.
- [ ] **M2.3: CSS Portability**: Implement CSS Custom Properties (Variables) to allow the host page to skin the chat interface.

## Phase 3: Interaction & State Management
- [ ] **M3.1: The Visitor Pattern**: Implement the `accept()` method in activity components to allow `<chat-interaction>` tags to modify the visual state of an existing activity.
- [ ] **M3.2: Interaction Serialization**: Build the logic to capture user events (clicks/inputs) and transform them into valid `<chat-interaction>` XML strings for the chat log.
- [ ] **M3.3: Replay Integrity**: Ensure that refreshing the page and reloading the chat log accurately "replays" the state of all activities through the sequential application of interactions.

## Phase 4: Testing & Hardening
- [ ] **M4.1: Error Handling**: Implement "Invalid activity specification" fallbacks and 404 handling for the registry.
- [ ] **M4.2: Concurrent Activity Management**: Ensure multiple activities with different `activity-id`s can coexist and receive targeted updates without cross-talk.
- [ ] **M4.3: Prototype Deployment**: Demonstrate a full loop: LLM sends XML -> Registry serves component -> User interacts -> Selection is logged.